
# Отчёт по анализу и оптимизации памяти в C#-приложении

## **Цель**

Изучить методы анализа и оптимизации использования памяти в приложении на C#, выявить и устранить утечки памяти, а также улучшить производительность за счёт оптимизации работы сборщика мусора.

## **Ход работы**

### **1. Анализ использования памяти**

Для анализа памяти я использовал встроенные инструменты Visual Studio (**Диагностические инструменты**):

1. Запустил приложение в режиме отладки.
2. Открыл вкладку "Использование памяти" и сделал два снимка:
   - Первый снимок перед выполнением основной логики.
   - Второй снимок после выполнения действий, вызывающих потенциальные утечки.
3. Сравнил снимки и нашёл объекты, которые оставались в памяти, хотя они больше не использовались.

**Место для кода до исправления:**

```csharp
using System;
using System.Collections.Generic;

class Program
{
    static List<byte[]> memoryLeakList = new List<byte[]>();

    static void Main(string[] args)
    {
        Console.WriteLine("Начало работы приложения...");

        // Эмуляция утечки памяти
        for (int i = 0; i < 100000; i++)
        {
            memoryLeakList.Add(new byte[1024]); // Каждый объект занимает 1 КБ.
        }

        Console.WriteLine("Объекты созданы. Нажмите любую клавишу для завершения работы.");
        Console.ReadKey();
    }
}

```

---

### **2. Устранение утечек памяти**

После анализа я выяснил, что утечка возникала из-за:
- Неправильного использования событий (не было отписки).
- Отсутствия освобождения ресурсов в некоторых местах.

**Решения:**
1. Для событий добавил явную отписку с помощью `-=`.
2. Для работы с файлами и ресурсами использовал конструкцию `using`.

**Место для кода после исправления:**

```csharp
using System;
using System.Runtime;

class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Настройка сборщика мусора...");

        // Установка режима низкой задержки
        GCSettings.LatencyMode = GCLatencyMode.SustainedLowLatency;

        Console.WriteLine($"GC Latency Mode: {GCSettings.LatencyMode}");

        // Создание и использование больших объектов
        byte[] largeArray = new byte[85 * 1024]; // Пример объекта в LOH (Large Object Heap)
        Console.WriteLine("Большой объект создан.");

        // Освобождение памяти
        largeArray = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();

        Console.WriteLine("GC завершил работу. Нажмите любую клавишу для завершения работы.");
        Console.ReadKey();
    }
}

```

---

### **3. Оптимизация работы сборщика мусора**

Чтобы улучшить производительность, я:
- Настроил сборщик мусора на низкую задержку (`GCLatencyMode.SustainedLowLatency`).
- Минимизировал использование объектов в **Large Object Heap** (LOH), разбив большие массивы на более мелкие.

Пример настройки:

```csharp
GCSettings.LatencyMode = GCLatencyMode.SustainedLowLatency;
```

---

## **Результаты**

После внесённых изменений:
1. Потребление памяти уменьшилось (согласно результатам снимков памяти).
2. Утечки памяти устранены.
3. Производительность приложения улучшилась за счёт оптимизированной работы сборщика мусора.

---

## **Выводы**

- Я научился находить и исправлять утечки памяти в C#-приложении.
- Освоил инструменты анализа памяти в Visual Studio.
- Оптимизировал использование памяти и работу сборщика мусора для повышения производительности.

